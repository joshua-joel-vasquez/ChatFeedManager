<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Unified Chat Overlay</title>
  <style>
    :root{
      --bg: rgba(0,0,0,0);
      --panel: rgba(0,0,0,0.45);
      --text: #fff;
      --muted: rgba(255,255,255,0.75);
      --chip: rgba(255,255,255,0.10);
      --chip2: rgba(255,255,255,0.16);
      --border: rgba(255,255,255,0.12);
      --shadow: rgba(0,0,0,0.35);
      --radius: 14px;
      --font: 16px;
      --line: 1.25;
    }

    html, body {
      margin: 0; padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: var(--font);
      line-height: var(--line);
      overflow: hidden;
    }

    .wrap{
      width: 100vw;
      height: 100vh;
      padding: 12px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .topbar{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-radius: var(--radius);
      background: var(--panel);
      border: 1px solid var(--border);
      box-shadow: 0 10px 30px var(--shadow);
      backdrop-filter: blur(6px);
    }

    .title{
      font-weight: 700;
      letter-spacing: 0.2px;
      white-space: nowrap;
    }

    .right{
      color: var(--muted);
      font-size: 0.85em;
      white-space: nowrap;
      max-width: 70vw;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .chat{
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .list{
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow: hidden;
      justify-content: flex-start;
    }

    .msg{
      display: grid;
      grid-template-columns: 46px 1fr;
      gap: 10px;
      padding: 10px 12px;
      border-radius: var(--radius);
      background: var(--panel);
      border: 1px solid var(--border);
      box-shadow: 0 10px 30px var(--shadow);
      backdrop-filter: blur(6px);
      transform-origin: top left;
      animation: pop 140ms ease-out;
    }

    @keyframes pop {
      from { transform: translateY(-6px); opacity: 0.0; }
      to   { transform: translateY(0px); opacity: 1.0; }
    }

    .avatar{
      width: 44px; height: 44px;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.08);
      display:flex; align-items:center; justify-content:center;
      font-weight: 700;
      color: rgba(255,255,255,0.85);
      user-select: none;
    }

    .avatar img{
      width: 100%; height: 100%;
      object-fit: cover;
      display: block;
    }

    .meta{
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      min-width: 0;
    }

    .name{
      font-weight: 750;
      max-width: 60vw;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .plat{
      padding: 3px 7px;
      border-radius: 999px;
      background: var(--chip2);
      border: 1px solid var(--border);
      font-size: 0.78em;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.6px;
    }

    .text{
      margin-top: 6px;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .time{
      color: rgba(255,255,255,0.55);
      font-size: 0.78em;
      margin-left: auto;
      white-space: nowrap;
    }

    .hidden{ display: none !important; }
  </style>
</head>

<body>
  <div class="wrap">
    <div id="topbar" class="topbar">
      <div class="title">Unified Chat</div>
      <div class="right"><span id="status">Connecting…</span></div>
    </div>

    <div class="chat">
      <div id="list" class="list"></div>
    </div>
  </div>

<script>
(function(){
  const qs = new URLSearchParams(location.search);

  function clampInt(v, min, max, def){
    const n = parseInt(v, 10);
    if (Number.isFinite(n)) return Math.max(min, Math.min(max, n));
    return def;
  }

  const isFileOrigin = (location.protocol === "file:");
  const base = qs.get("base") || (isFileOrigin ? "http://127.0.0.1:8080" : "");

  const FEED_URL = qs.get("feed") || (base ? (base + "/chat_feed.json") : "chat_feed.json");
  const EXTRA_URL_RAW = qs.get("extra");
  const EXTRA_URL = (EXTRA_URL_RAW == null ? (base ? (base + "/overlay_additions.jsonl") : "overlay_additions.jsonl") : EXTRA_URL_RAW);
  const EXTRA_ENABLED = !!(EXTRA_URL && EXTRA_URL !== "0" && EXTRA_URL !== "false");

  const MAX_RENDER = clampInt(qs.get("max"), 1, 200, 50);
  const POLL_MS = clampInt(qs.get("poll"), 100, 5000, 350);
  const SHOW_TOPBAR = (qs.get("topbar") ?? "1") !== "0";
  const FONT_SIZE = clampInt(qs.get("font"), 10, 32, 16);

  document.documentElement.style.setProperty("--font", FONT_SIZE + "px");
  if (!SHOW_TOPBAR) document.getElementById("topbar").classList.add("hidden");

  const listEl = document.getElementById("list");
  const statusEl = document.getElementById("status");

  let lastRenderSig = "";
  let lastOkAt = 0;

  function escapeHtml(s){
    return (s ?? "").replace(/[&<>\"']/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;"
    }[c]));
  }

  function formatTime(ms){
    const d = new Date(ms);
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    const ss = String(d.getSeconds()).padStart(2,"0");
    return `${hh}:${mm}:${ss}`;
  }

  function parseJsonl(text){
    const out = [];
    const lines = (text || "").split(/\r?\n/);  /* FIXED */
    for (const ln of lines){
      const s = ln.trim();
      if (!s) continue;
      try{
        const obj = JSON.parse(s);
        if (obj && typeof obj === 'object') out.push(obj);
      }catch(e){}
    }
    return out;
  }

  function fingerprint(m){
    const plat = String(m.platform || m.source || "unknown").toLowerCase();
    const ts = Number(m.ts || 0) || 0;
    const user = (m.user && typeof m.user === 'object') ? m.user : {};
    const name = String(user.name || user.displayName || user.username || user.handle || "");
    const text = String(m.message || m.text || "");
    return `${plat}|${name}|${ts}|${text}`.slice(0, 800);
  }

  function mergeMessages(feedMsgs, extraMsgs){
    const merged = [];
    const seen = new Set();

    const push = (m) => {
      if (!m || typeof m !== 'object') return;
      const t = String(m.type || 'chat').toLowerCase();
      if (t !== 'chat') return;

      const user = (m.user && typeof m.user === 'object') ? m.user : {};
      const obj = {
        type: 'chat',
        ts: Number(m.ts || 0) || Date.now(),
        platform: String(m.platform || m.source || 'unknown'),
        message: String(m.message || m.text || ''),
        user,
      };

      const fp = fingerprint(obj);
      if (seen.has(fp)) return;
      seen.add(fp);
      merged.push(obj);
    };

    for (const m of (Array.isArray(feedMsgs) ? feedMsgs : [])) push(m);
    for (const m of (Array.isArray(extraMsgs) ? extraMsgs : [])) push(m);

    merged.sort((a,b) => (a.ts||0) - (b.ts||0));
    return merged;
  }

  function renderMessage(m){
    const user = m.user || {};
    const plat = (m.platform || "unknown").toUpperCase();
    const name = user.name || user.displayName || user.username || user.handle || "Unknown";
    const msg = m.message || "";

    const avatarUrl = (user.avatar || "").trim();
    const initials = (name || "?").slice(0,1).toUpperCase();

    return `
      <div class="msg">
        <div class="avatar">
          ${avatarUrl ? `<img src="${escapeHtml(avatarUrl)}" alt="" />` : `<span>${escapeHtml(initials)}</span>`}
        </div>
        <div>
          <div class="meta">
            <span class="plat">${escapeHtml(plat)}</span>
            <span class="name">${escapeHtml(name)}</span>
            <span class="time">${formatTime(m.ts || Date.now())}</span>
          </div>
          <div class="text">${escapeHtml(msg)}</div>
        </div>
      </div>
    `;
  }

  function renderFeed(feed){
    const msgs = Array.isArray(feed.messages) ? feed.messages : [];
    const sliced = msgs.slice(-MAX_RENDER);
    const newestFirst = [...sliced].sort((a,b) => (b.ts||0) - (a.ts||0));
    listEl.innerHTML = newestFirst.map(renderMessage).join("");

    lastOkAt = Date.now();
    statusEl.textContent = `Live • ${newestFirst.length} msgs`;
  }

  async function fetchJson(url){
    const u = url + (url.includes("?") ? "&" : "?") + "t=" + Date.now();
    const res = await fetch(u, { cache: "no-store" });
    if (!res.ok) throw new Error(`Feed HTTP ${res.status} (${url})`);
    return res.json();
  }

  async function fetchText(url){
    const u = url + (url.includes("?") ? "&" : "?") + "t=" + Date.now();
    const res = await fetch(u, { cache: "no-store" });
    if (!res.ok) throw new Error(`Extra HTTP ${res.status} (${url})`);
    return res.text();
  }

  async function poll(){
    try{
      statusEl.textContent = `Connecting… (${FEED_URL})`;

      const feedPromise = fetchJson(FEED_URL);

      let extraPromise = Promise.resolve([]);
      if (EXTRA_ENABLED){
        extraPromise = fetchText(EXTRA_URL).then(parseJsonl).catch(()=>[]);
      }

      const [feed, extra] = await Promise.all([feedPromise, extraPromise]);
      const merged = mergeMessages(feed.messages, extra);

      const updated = merged.length ? Math.max(...merged.map(m => Number(m.ts||0)||0)) : 0;
      const sig = `${updated}|${merged.length}`;

      if (sig !== lastRenderSig){
        lastRenderSig = sig;
        renderFeed({ ...feed, messages: merged, updatedTs: updated });
      } else {
        if (Date.now() - lastOkAt > 2000) statusEl.textContent = `Live • ${merged.length} msgs`;
      }
    } catch(e){
      const msg = (e && e.message) ? e.message : String(e);
      let hint = "";
      if (/Failed to fetch|NetworkError/i.test(msg)){
        if (location.protocol === "file:"){
          hint = "If you used OBS Local File, switch to the URL http://127.0.0.1:8080/overlay.html (recommended).";
        } else if (location.protocol === "https:"){
          hint = "HTTPS pages can’t fetch http://127.0.0.1 (mixed content). Use the http://127.0.0.1:8080/ URL.";
        } else {
          hint = "Make sure run_all.py is running and http://127.0.0.1:8080/chat_feed.json opens in your browser.";
        }
      }
      statusEl.textContent = `Error: ${msg}${hint ? " • " + hint : ""}`;
    } finally {
      setTimeout(poll, POLL_MS);
    }
  }

  poll();
})();
</script>
</body>
</html>
